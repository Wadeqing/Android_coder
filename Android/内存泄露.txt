
如果一个无用对象(不需要再使用的对象)仍然被其他对象持有引用，造成该对象无法被系统回 收，以致该对象在堆中所占用的内存单元无法被释放而造成内存空间浪费，这中情况就是内存泄 露。 
常见的内存泄露场景：
1、单例导致内存泄露
	
2、静态变量导致内存泄露
   静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后， 它所持有的引用只有等到进程结束才会释放。  在 Android 开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露， 所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地 使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为 null， 使其不再持有引用，这样也可以避免内存泄露。 


3、非静态内部类导致内存泄露
   非静态内部类(包括匿名内部类)默认就会持有外部类的引用，当非静态内部类对象的生命周期 比外部类对象的生命周期长时，就会导致内存泄露。 通常在 Android 开发中如果要使用内部类，但又要规避内存泄露，一般都会采用静态内部类+弱 引用的方式。 
上面的做法确实避免了 Activity 导致的内存泄露，发送的 msg 不再已经没有持有 Activity 的引用 了，但是 msg 还是有可能存在消息队列 MessageQueue 中，所以更好的是在 Activity 销毁时就将 mHandler 的回调和发送的消息给移除掉。 
非静态内部类造成内存泄露还有一种情况就是使用 Thread 或者 AsyncTask。 

4、未取消注册或回调导致内存泄露


5、Timer和TimerTask导致内存泄露
   activity销毁的时候  取消一下

6、集合中的对象未清理导致内存泄露
   这个比较好理解，如果一个对象放入到 ArrayList、HashMap 等集合中，这个集合就会持有该对象 的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用(而 此对象已经无用了)，这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那 些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合 remove，或 者 clear 集合，以避免内存泄漏。 
7、资源未关闭或释放
   在使用 IO、File 流或者 Sqlite、Cursor 等资源时要及时关闭。这些资源在进行读写操作时通常都 使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。 因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。 

8、属性动画
   动画同样是一个耗时任务，比如在 Activity 中启动了属性动画(ObjectAnimator)，但是在销毁 的时候，没有调用 cancle 方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去， 动画引用所在的控件，所在的控件引用 Activity，这就造成 Activity 无法正常释放。因此同样要 在 Activity 销毁的时候 cancel 掉属性动画，避免发生内存泄漏。
 
9、webView
   在销毁 WebView 之前需要先将 WebView 从父容器中移除，然后在销毁 WebView。 详细分析过程请参考这篇文章: 
	
总结 
内存泄露在 Android 内存优化是一个比较重要的一个方面，很多时候程序中发生了内存泄露我们 不一定就能注意到，所有在编码的过程要养成良好的习惯。总结下来只要做到以下这几点就能避 免大多数情况的内存泄漏: 
构造单例的时候尽量别用 Activity 的引用;
 静态引用时注意应用对象的置空或者少用静态引用; 
使用静态内部类+软引用代替非静态内部类; 
及时取消广播或者观察者注册;
 耗时任务、属性动画在 Activity 销毁时记得 cancel; 
文件流、Cursor 等资源及时关闭; 
Activity 销毁时 WebView 的移除和销毁。 


